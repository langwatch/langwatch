import { createHash } from "crypto";
import { getEnvironment, Instance, Ksuid } from "@langwatch/ksuid";
import { KSUID_RESOURCES } from "~/utils/constants";

/**
 * Generates a deterministic evaluation run ID from evaluation data.
 * This ensures that replaying events produces the same IDs for idempotency,
 * while maintaining K-sortability by creation time.
 *
 * The ID is generated by:
 * 1. Hashing the combination of tenantId and evaluationId
 * 2. Using the hash to create deterministic KSUID components
 * 3. Using the timestamp for K-sortability
 *
 * @param tenantId - The tenant ID
 * @param evaluationId - The evaluation ID
 * @param timestampMs - The timestamp in milliseconds
 * @returns A deterministic KSUID string for the evaluation run
 *
 * @example
 * ```typescript
 * const stateId = IdUtils.generateDeterministicEvaluationRunId(
 *   tenantId, evaluationId, Date.now()
 * );
 * ```
 */
function generateDeterministicEvaluationRunId(
  tenantId: string,
  evaluationId: string,
  timestampMs: number,
): string {
  // Create hash input from tenant and evaluation
  const hashInput = `${tenantId}:${evaluationId}`;

  // Create a deterministic hash
  const hash = createHash("sha256").update(hashInput).digest();

  // Use first 8 bytes of hash as instance identifier
  const instanceIdentifier = new Uint8Array(hash.subarray(0, 8));

  // Create a deterministic instance using RANDOM scheme
  const instance = new Instance(Instance.schemes.RANDOM, instanceIdentifier);

  // Convert milliseconds to seconds for KSUID timestamp
  const timestampSeconds = Math.floor(timestampMs / 1000);

  // Use sequence 0 for deterministic generation
  const sequenceId = 0;

  // Create KSUID with deterministic components
  const ksuid = new Ksuid(
    getEnvironment(),
    KSUID_RESOURCES.EVALUATION,
    timestampSeconds,
    instance,
    sequenceId,
  );

  return ksuid.toString();
}

export const IdUtils = {
  generateDeterministicEvaluationRunId,
} as const;
