import { createHash } from "crypto";
import { getEnvironment, Instance, Ksuid } from "@langwatch/ksuid";
import { KSUID_RESOURCES } from "~/utils/constants";

/**
 * Generates a deterministic batch result ID from result data.
 * This ensures that replaying events produces the same IDs for idempotency,
 * while maintaining K-sortability by creation time.
 *
 * The ID is generated by:
 * 1. Hashing the combination of tenantId, runId, index, targetId, resultType, and optionally evaluatorId
 * 2. Using the hash to create deterministic KSUID components
 * 3. Using the timestamp for K-sortability
 *
 * @param tenantId - The tenant ID
 * @param runId - The experiment run ID
 * @param index - The row index in the dataset
 * @param targetId - The target ID
 * @param resultType - The result type ('target' or 'evaluator')
 * @param evaluatorId - The evaluator ID (null for target results)
 * @param timestampMs - The timestamp in milliseconds
 * @returns A deterministic KSUID string for the batch result
 *
 * @example
 * ```typescript
 * // Target result
 * const targetId = IdUtils.generateDeterministicBatchResultId(
 *   tenantId, runId, 0, "target1", "target", null, Date.now()
 * );
 *
 * // Evaluator result
 * const evalId = IdUtils.generateDeterministicBatchResultId(
 *   tenantId, runId, 0, "target1", "evaluator", "eval1", Date.now()
 * );
 * ```
 */
function generateDeterministicBatchResultId(
  tenantId: string,
  runId: string,
  index: number,
  targetId: string,
  resultType: "target" | "evaluator",
  evaluatorId: string | null,
  timestampMs: number,
): string {
  // Create hash input based on result type
  const hashInput = evaluatorId
    ? `${tenantId}:${runId}:${index}:${targetId}:${evaluatorId}:${resultType}`
    : `${tenantId}:${runId}:${index}:${targetId}:${resultType}`;

  // Create a deterministic hash
  const hash = createHash("sha256").update(hashInput).digest();

  // Use first 8 bytes of hash as instance identifier
  const instanceIdentifier = new Uint8Array(hash.subarray(0, 8));

  // Create a deterministic instance using RANDOM scheme
  const instance = new Instance(Instance.schemes.RANDOM, instanceIdentifier);

  // Convert milliseconds to seconds for KSUID timestamp
  const timestampSeconds = Math.floor(timestampMs / 1000);

  // Use sequence 0 for deterministic generation
  const sequenceId = 0;

  // Create KSUID with deterministic components
  const ksuid = new Ksuid(
    getEnvironment(),
    KSUID_RESOURCES.BATCH_RESULT,
    timestampSeconds,
    instance,
    sequenceId,
  );

  return ksuid.toString();
}

export const IdUtils = {
  generateDeterministicBatchResultId,
} as const;
