import { getEnvironment, Instance, Ksuid } from "@langwatch/ksuid";
import { createHash } from "crypto";
import { KSUID_RESOURCES } from "~/utils/constants";
import { EventUtils } from "../../../";
import type { SpanReceivedEvent } from "../schemas/events";
import { TraceRequestUtils } from "./traceRequest.utils";

/**
 * Generates a deterministic span record ID from a SpanReceivedEvent.
 * This ensures that replaying events produces the same IDs for idempotency,
 * while maintaining K-sortability by span start time.
 *
 * The ID is generated by:
 * 1. Validating the tenant ID
 * 2. Hashing the combination of tenantId, traceId, and spanId
 * 3. Using the hash to create deterministic KSUID components
 * 4. Using the span's timestamp for K-sortability
 *
 * @param event - The SpanReceivedEvent containing span data
 * @returns A deterministic KSUID string for the span record
 *
 * @example
 * ```typescript
 * const recordId = generateDeterministicSpanRecordId(spanReceivedEvent);
 * // Always returns the same ID for the same event
 * ```
 */
function generateDeterministicSpanRecordId(event: SpanReceivedEvent): string {
  const { traceId, spanId } = TraceRequestUtils.normalizeOtlpSpanIds(
    event.data.span,
  );
  const startTimeUnixMs = TraceRequestUtils.convertUnixNanoToUnixMs(
    TraceRequestUtils.normalizeOtlpUnixNano(event.data.span.startTimeUnixNano),
  );

  return generateDeterministicSpanRecordIdFromData(
    String(event.tenantId),
    traceId,
    spanId,
    startTimeUnixMs,
  );
}

/**
 * Generates a deterministic span record ID from raw span data.
 * This is a fallback for repository operations where the full event is not available.
 * Event handlers should use generateDeterministicSpanRecordId(event) instead.
 *
 * @param tenantId - The tenant ID
 * @param traceId - The OpenTelemetry trace ID
 * @param spanId - The OpenTelemetry span ID
 * @param startTimeUnixMs - The span start timestamp in milliseconds
 * @returns A deterministic KSUID string for the span record
 */
function generateDeterministicSpanRecordIdFromData(
  tenantId: string,
  traceId: string,
  spanId: string,
  startTimeUnixMs: number,
): string {
  EventUtils.validateTenantId(
    { tenantId },
    "generateDeterministicSpanRecordIdFromData",
  );

  // Create a deterministic hash from tenantId + traceId + spanId
  const hash = createHash("sha256")
    .update(`${tenantId}:${traceId}:${spanId}`)
    .digest();

  // Use first 8 bytes of hash as instance identifier
  const instanceIdentifier = new Uint8Array(hash.subarray(0, 8));

  // Create a deterministic instance using RANDOM scheme
  const instance = new Instance(Instance.schemes.RANDOM, instanceIdentifier);

  // Convert milliseconds to seconds for KSUID timestamp
  const timestampSeconds = Math.floor(startTimeUnixMs / 1000);

  // Use sequence 0 for deterministic generation
  const sequenceId = 0;

  // Create KSUID with deterministic components
  const ksuid = new Ksuid(
    getEnvironment(),
    "span",
    timestampSeconds,
    instance,
    sequenceId,
  );

  return ksuid.toString();
}

/**
 * Generates a deterministic trace summary ID from a SpanReceivedEvent.
 * This ensures that replaying events produces the same IDs for idempotency,
 * while maintaining K-sortability by trace start time.
 *
 * The ID is generated by:
 * 1. Validating the tenant ID
 * 2. Hashing the combination of tenantId and traceId
 * 3. Using the hash to create deterministic KSUID components
 * 4. Using the trace's first span timestamp for K-sortability
 *
 * @param event - The SpanReceivedEvent containing trace data
 * @returns A deterministic KSUID string for the trace summary
 *
 * @example
 * ```typescript
 * const traceummaryId = generateDeterministicTraceSummaryId(spanReceivedEvent);
 * // Always returns the same ID for the same event
 * ```
 */
function generateDeterministicTraceSummaryId(event: SpanReceivedEvent): string {
  const { traceId } = TraceRequestUtils.normalizeOtlpSpanIds(event.data.span);
  const startTimeUnixMs = TraceRequestUtils.convertUnixNanoToUnixMs(
    TraceRequestUtils.normalizeOtlpUnixNano(event.data.span.startTimeUnixNano),
  );

  return generateDeterministicTraceSummaryIdFromData(
    String(event.tenantId),
    traceId,
    startTimeUnixMs,
  );
}

/**
 * Generates a deterministic trace summary ID from raw trace data.
 * This is a fallback for repository operations where the full event is not available.
 * Event handlers should use generateDeterministicTraceSummaryId(event) instead.
 *
 * @param tenantId - The tenant ID
 * @param traceId - The OpenTelemetry trace ID
 * @param startTimeUnixMs - The trace's first span start timestamp in milliseconds
 * @returns A deterministic KSUID string for the trace summary
 *
 * @example
 * ```typescript
 * const traceummaryId = generateDeterministicTraceSummaryIdFromData(tenantId, traceId, startTimeUnixMs);
 * // Always returns the same ID for the same inputs
 * ```
 */
function generateDeterministicTraceSummaryIdFromData(
  tenantId: string,
  traceId: string,
  startTimeUnixMs: number,
): string {
  EventUtils.validateTenantId(
    { tenantId },
    "generateDeterministicTraceSummaryIdFromData",
  );

  // Create a deterministic hash from tenantId + traceId + spanId
  const hash = createHash("sha256").update(`${tenantId}:${traceId}`).digest();

  // Use first 8 bytes of hash as instance identifier
  const instanceIdentifier = new Uint8Array(hash.subarray(0, 8));

  // Create a deterministic instance using RANDOM scheme
  const instance = new Instance(Instance.schemes.RANDOM, instanceIdentifier);

  // Convert milliseconds to seconds for KSUID timestamp
  const timestampSeconds = Math.floor(startTimeUnixMs / 1000);

  // Use sequence 0 for deterministic generation
  const sequenceId = 0;

  // Create KSUID with deterministic components
  const ksuid = new Ksuid(
    getEnvironment(),
    KSUID_RESOURCES.TRACE_SUMMARY,
    timestampSeconds,
    instance,
    sequenceId,
  );

  return ksuid.toString();
}

export const IdUtils = {
  generateDeterministicSpanRecordId,
  generateDeterministicSpanRecordIdFromData,
  generateDeterministicTraceSummaryId,
  generateDeterministicTraceSummaryIdFromData,
} as const;
