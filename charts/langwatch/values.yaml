# Global configuration
global:
  env: production
  podSecurityContext:
    runAsNonRoot: true
    runAsUser: 1000
    fsGroup: 1000
  containerSecurityContext:
    allowPrivilegeEscalation: false
    capabilities:
      drop:
        - ALL
    readOnlyRootFilesystem: true
  scheduling:
    nodeSelector: {}
    affinity: {}
    tolerations: []
  monitoring:
    enabled: false
    prometheusAnnotations: true

# Prometheus monitoring configuration
prometheus:
  source: "built-in" # "built-in" or "external"

  external:
    # Reference to existing secret containing Prometheus connection details
    secretName: ""
    secretKeys:
      host: "host"
      port: "port"
      username: "username" # Optional for basic auth
      password: "password" # Optional for basic auth
      # Optional: full connection string
      connectionString: "connection-string"

  # Prometheus server configuration
  server:
    # Global Prometheus configuration
    global:
      scrape_interval: 15s
      evaluation_interval: 15s

    # Persistence configuration
    persistence:
      enabled: true
      size: 6Gi
      storageClass: ""

    # Retention and resources
    retention: 60d
    resources:
      requests:
        cpu: 200m
        memory: 512Mi
      limits:
        cpu: 500m
        memory: 2Gi

    # RBAC configuration (enabled by default)
    rbac:
      create: true
      includeDefaultRules: true

    # ServiceAccount configuration
    serviceAccount:
      create: true

    # Service configuration to match old setup
    service:
      type: ClusterIP
      port: 9090

    # Security context to match old setup
    securityContext:
      runAsNonRoot: true
      runAsUser: 65534
      fsGroup: 65534

    # Custom scrape configs to match old setup
    extraScrapeConfigs: |
      - job_name: 'langwatch'
        kubernetes_sd_configs:
          - role: pod
            namespaces:
              names:
                - {{ .Release.Namespace }}
        metrics_path: '/metrics'
        scheme: http
        relabel_configs:
          - source_labels: [__meta_kubernetes_pod_annotation_prometheus_io_scrape]
            action: keep
            regex: true
          - source_labels: [__meta_kubernetes_pod_ip]
            action: replace
            target_label: __address__
            replacement: $1:5560
          - source_labels: [__meta_kubernetes_pod_name]
            action: replace
            target_label: pod
        {{- if .Values.app.env.METRICS_API_KEY }}
        bearer_token: "{{ .Values.app.env.METRICS_API_KEY }}"
        {{- end }}

      - job_name: 'langwatch-workers'
        kubernetes_sd_configs:
          - role: pod
            namespaces:
              names:
                - {{ .Release.Namespace }}
        metrics_path: '/metrics'
        scheme: http
        relabel_configs:
          - source_labels: [__meta_kubernetes_pod_annotation_prometheus_io_scrape]
            action: keep
            regex: true
          - source_labels: [__meta_kubernetes_pod_annotation_prometheus_io_path]
            action: replace
            target_label: __metrics_path__
            regex: (.+)
          - source_labels: [__meta_kubernetes_pod_ip]
            action: replace
            target_label: __address__
            replacement: $1:2999
          - source_labels: [__meta_kubernetes_pod_name]
            action: replace
            target_label: pod
        {{- if .Values.app.env.METRICS_API_KEY }}
        bearer_token: "{{ .Values.app.env.METRICS_API_KEY }}"
        {{- end }}

      - job_name: 'kubernetes-cadvisor'
        scheme: https
        tls_config:
          ca_file: /var/run/secrets/kubernetes.io/serviceaccount/ca.crt
          insecure_skip_verify: true
        bearer_token_file: /var/run/secrets/kubernetes.io/serviceaccount/token
        kubernetes_sd_configs:
          - role: node
        relabel_configs:
          - action: labelmap
            regex: __meta_kubernetes_node_label_(.+)
          - target_label: __address__
            replacement: kubernetes.default.svc:443
          - source_labels: [__meta_kubernetes_node_name]
            regex: (.+)
            target_label: __metrics_path__
            replacement: /api/v1/nodes/$1/proxy/metrics/cadvisor

# Image configurations
images:
  app:
    repository: langwatch/langwatch
    tag: latest
    pullPolicy: Always
  langwatch_nlp:
    repository: langwatch/langwatch_nlp
    tag: latest
    pullPolicy: Always
  langevals:
    repository: langwatch/langevals
    tag: latest
    pullPolicy: Always
  postgres:
    repository: postgres
    tag: "16"
    pullPolicy: IfNotPresent
  redis:
    repository: redis
    tag: alpine
    pullPolicy: IfNotPresent
  opensearch:
    repository: langwatch/opensearch-lite
    tag: latest
    pullPolicy: IfNotPresent

# Service configurations
app:
  replicaCount: 1
  service:
    type: ClusterIP
    port: 5560
  resources:
    requests:
      cpu: 100m
      memory: 512Mi
    limits:
      cpu: 500m
      memory: 1024Mi
  env:
    SKIP_ENV_VALIDATION: "true"
    DISABLE_PII_REDACTION: "true"
    # PostgreSQL connection - automatically configured based on postgres.source
    DATABASE_URL: "" # Will be set by template function
    # OpenSearch connection - automatically configured based on opensearch.source
    ELASTICSEARCH_NODE_URL: "" # Will be set by template function
    IS_OPENSEARCH: "true"
    # Redis connection - automatically configured based on redis.source
    REDIS_URL: "" # Will be set by template function
    LANGWATCH_NLP_SERVICE: "http://{{ .Release.Name }}-langwatch-nlp:5561"
    LANGEVALS_ENDPOINT: "http://{{ .Release.Name }}-langevals:5562"
    # User provided environment variables
    BASE_HOST: "http://localhost:5560"
    NEXTAUTH_URL: "http://localhost:5560"
    NEXTAUTH_SECRET: "" # Users must provide this values
    API_TOKEN_JWT_SECRET: "" # Users must provide this values
    CRON_API_KEY: "" # Users must provide this value for cronjob authentication
    METRICS_API_KEY: "" # Set this for metrics authentication (will be stored in Kubernetes Secret)
    # SENDGRID_API_KEY: ""  # Optional
    # SSO Configuration (Azure AD example)
    # AZURE_AD_CLIENT_ID: "" # Set for Azure AD SSO
    # AZURE_AD_CLIENT_SECRET: "" # Set for Azure AD SSO
    # NEXTAUTH_PROVIDERS: "" # JSON string for SSO providers

langwatch_nlp:
  replicaCount: 1
  service:
    type: ClusterIP
    port: 5561
  resources:
    requests:
      cpu: 500m
      memory: 1024Mi
    limits:
      cpu: 1000m
      memory: 2048Mi
  env:
    LANGWATCH_ENDPOINT: "http://{{ .Release.Name }}-app:5560"
    # For when running on minikube on Mac OS
    # STUDIO_RUNTIME: "async"

langevals:
  replicaCount: 1
  service:
    type: ClusterIP
    port: 5562
  resources:
    requests:
      cpu: 500m
      memory: 4096Mi
    limits:
      cpu: 1000m
      memory: 6144Mi

postgres:
  source: "built-in" # "built-in" or "external"

  # External PostgreSQL (when source: "external")
  external:
    # Reference to existing secret containing connection details
    secretName: ""
    secretKeys:
      host: "host"
      port: "port"
      database: "database"
      username: "username"
      password: "password"
      # Optional: full connection string as alternative
      connectionString: "connection-string"
      # SSL configuration keys in secret
      sslMode: "ssl-mode"
      sslCert: "ssl-cert"
      sslKey: "ssl-key"
      sslRootCert: "ssl-root-cert"

  # Built-in PostgreSQL configuration (when source: "built-in")
  auth:
    username: prisma
    password: "" # Will be auto-generated if not provided
    database: mydb
    # Use existing secret for production
    existingSecret: ""
    secretKeys:
      userPasswordKey: password
      databaseKey: database
      usernameKey: username

  postgresqlDataDir: /var/lib/postgresql/data

  persistence:
    enabled: true
    existingClaim: "data-{{ .Release.Name }}-postgres-0"
    size: 10Gi
    storageClass: ""

  resources:
    requests:
      cpu: 100m
      memory: 256Mi
    limits:
      cpu: 500m
      memory: 512Mi

redis:
  source: "built-in" # "built-in" or "external"

  external:
    # Reference to existing secret containing Redis connection details
    secretName: ""
    secretKeys:
      host: "host"
      port: "port"
      password: "password" # Optional for auth
      username: "username" # Optional for Redis 6+ ACL
      # Optional: full connection string as alternative
      connectionString: "connection-string"

  # Built-in Redis configuration (when source: "built-in")
  # Uses Bitnami Redis chart dependency

  auth:
    enabled: true
    password: "" # Will be auto-generated if not provided
    existingSecret: "" # Use existing secret for production
    secretKeys:
      passwordKey: "password"

  architecture: standalone
  master:
    persistence:
      enabled: true
      size: 5Gi
      storageClass: ""
    resources:
      requests:
        cpu: 100m
        memory: 128Mi
      limits:
        cpu: 300m
        memory: 256Mi

opensearch:
  source: "built-in" # "built-in" or "external"

  external:
    # Reference to existing secret containing OpenSearch connection details
    secretName: ""
    secretKeys:
      host: "host"
      port: "port"
      username: "username" # Optional for auth
      password: "password" # Optional for auth
      # Optional: full connection string as alternative
      connectionString: "connection-string"
      # SSL configuration if needed
      sslCert: "ssl-cert"
      sslKey: "ssl-key"
      sslRootCert: "ssl-root-cert"

  # Built-in OpenSearch configuration (when source: "built-in")
  # Uses Bitnami OpenSearch chart dependency

  # Service configuration to match old setup
  service:
    type: ClusterIP
    ports:
      - name: http
        port: 9200
      - name: transport
        port: 9300

  # Resources configuration to match old setup
  resources:
    requests:
      cpu: 500m
      memory: 512Mi
    limits:
      cpu: 1000m
      memory: 1Gi

  auth:
    adminPassword: "" # Will be auto-generated if not provided
    existingSecret: "" # Use existing secret for production
    secretKeys:
      adminPasswordKey: "admin-password"

  # OpenSearch cluster configuration
  clusterName: "langwatch-cluster"
  nodeGroup:
    master:
      replicas: 1
      persistence:
        enabled: true
        size: 10Gi
        storageClass: ""
      resources:
        requests:
          cpu: 500m
          memory: 512Mi
        limits:
          cpu: 1000m
          memory: 1Gi
      javaOpts: "-Xms512m -Xmx512m -XX:+UseG1GC -XX:-UseSerialGC -XX:G1ReservePercent=25 -XX:+AlwaysPreTouch -XX:InitiatingHeapOccupancyPercent=30"

      # Security context to match old setup
      securityContext:
        enabled: true
        runAsUser: 1000
        fsGroup: 1000
        capabilities:
          add:
            - IPC_LOCK
            - SYS_RESOURCE

      # Health check configuration to match old setup
      livenessProbe:
        enabled: true
        initialDelaySeconds: 90
        periodSeconds: 30
        timeoutSeconds: 30
        failureThreshold: 3
      readinessProbe:
        enabled: true
        initialDelaySeconds: 60
        periodSeconds: 30
        timeoutSeconds: 30
        failureThreshold: 3

# CronJobs configuration
cronjobs:
  enabled: true
  # Global cronjob configuration
  image:
    repository: curlimages/curl
    tag: latest
    pullPolicy: IfNotPresent
  resources:
    requests:
      cpu: 100m
      memory: 64Mi
    limits:
      cpu: 100m
      memory: 64Mi

  # Individual cronjob configurations
  jobs:
    topicClustering:
      enabled: true
      schedule: "0 0 * * *" # At midnight every day
      endpoint: "/api/cron/schedule_topic_clustering"

    alertTriggers:
      enabled: true
      schedule: "*/3 * * * *" # Every 3 minutes
      endpoint: "/api/cron/triggers"

    tracesRetentionCleanup:
      enabled: true
      schedule: "0 1 * * *" # At 1 AM every day
      endpoint: "/api/cron/traces_retention_period_cleanup"

# Ingress configuration
ingress:
  enabled: false
  className: ""
  annotations: {}
  hosts:
    - host: chart-example.local
      http:
        paths:
          - path: /
            pathType: ImplementationSpecific
            backend:
              service:
                name: "langwatch-app"
                port:
                  number: 5560
  tls: []
