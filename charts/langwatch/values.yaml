# Global configuration
global:

# Auto-generation mode (development only)
autogen:
  enabled: false
  # Secret names for each service (auto-generated if not specified)
  secretNames:
    app: "" # defaults to {{ .Release.Name }}-app-secrets
    langevals: "" # defaults to {{ .Release.Name }}-langevals-secrets
    langwatch_nlp: "" # defaults to {{ .Release.Name }}-langwatch-nlp-secrets

# Image configurations
images:
  app:
    repository: langwatch/langwatch
    tag: latest
    pullPolicy: Always
  langwatch_nlp:
    repository: langwatch/langwatch_nlp
    tag: latest
    pullPolicy: Always
  langevals:
    repository: langwatch/langevals
    tag: latest
    pullPolicy: Always

# LangWatch app configurations
app:
  replicaCount: 1
  service: { type: ClusterIP, port: 5560 }
  resources:
    requests: { cpu: 250m,  memory: 2Gi }
    limits:   { cpu: 1000m, memory: 4Gi }

  nodeEnv: "production"

  credentialsEncryptionKey:
    value: ""
    secretKeyRef: { name: "", key: "" }

  cronApiKey:
    value: ""
    secretKeyRef: { name: "", key: "" }

  http:
    baseHost: "http://localhost:5560"
    publicUrl: "http://localhost:5560"

  features:
    skipEnvValidation: false
    disablePiiRedaction: false
    topicClustering: true

  upstreams:
    nlp:       { name: langwatch-nlp,  port: 5561 }
    langevals: { name: langevals,      port: 5562 }

  evaluators:
    azureOpenAI:
      enabled: false
      endpoint:
        value: ""
        secretKeyRef: { name: "", key: "" }
      apiKey:
        value: ""
        secretKeyRef: { name: "", key: "" }
    google:
      enabled: false
      credentials:
        value: ""
        secretKeyRef: { name: "", key: "" }

  datasetObjectStorage:
    enabled: true
    provider: awsS3
    bucket: "langwatch-dataset"

    providers:
      awsS3:
        accessKeyId:
          value: ""
          secretKeyRef: { name: "", key: "" }
        secretAccessKey:
          value: ""
          secretKeyRef: { name: "", key: "" }
        keySalt:
          value: ""
          secretKeyRef: { name: "", key: "" }

  email:
    enabled: false
    defaultFrom: ""
    provider: sendgrid
    sendgrid:
      apiKey:
        value: ""
        secretKeyRef: { name: "", key: "" }

  # use http.publicUrl
  nextAuth:
    provider: email
    secret:
      value: ""
      secretKeyRef: { name: "", key: "" }

    providers:
      auth0:
        clientId:
          value: ""
          secretKeyRef: { name: "", key: "" }
        clientSecret:
          value: ""
          secretKeyRef: { name: "", key: "" }
        issuer:
          value: ""
          secretKeyRef: { name: "", key: "" }
      azureAd:
        clientId:
          value: ""
          secretKeyRef: { name: "", key: "" }
        clientSecret:
          value: ""
          secretKeyRef: { name: "", key: "" }
        tenantId:
          value: ""
          secretKeyRef: { name: "", key: "" }
      cognito:
        clientId:
          value: ""
          secretKeyRef: { name: "", key: "" }
        clientSecret:
          value: ""
          secretKeyRef: { name: "", key: "" }
        issuer:
          value: ""
          secretKeyRef: { name: "", key: "" }
      github:
        clientId:
          value: ""
          secretKeyRef: { name: "", key: "" }
        clientSecret:
          value: ""
          secretKeyRef: { name: "", key: "" }
      gitlab:
        clientId:
          value: ""
          secretKeyRef: { name: "", key: "" }
        clientSecret:
          value: ""
          secretKeyRef: { name: "", key: "" }
      google:
        clientId:
          value: ""
          secretKeyRef: { name: "", key: "" }
        clientSecret:
          value: ""
          secretKeyRef: { name: "", key: "" }
      okta:
      clientId:
        value: ""
        secretKeyRef: { name: "", key: "" }
      clientSecret:
        value: ""
        secretKeyRef: { name: "", key: "" }
      issuer:
        value: ""
        secretKeyRef: { name: "", key: "" }

  telemetry:
    usage:
      enabled: true
    metrics:
      enabled: false
      apiKey:
        value: ""
        secretKeyRef: { name: "", key: "" }
    sentry:
      enabled: false
      dsn:
        value: ""
        secretKeyRef: { name: "", key: "" }

  # == Pass through directly to k8s ==

  podSecurityContext: {}
  securityContext: {}
  nodeSelector: {}
  tolerations: []
  affinity: {}
  pod:
    annotations: {}
    labels: {}
    topologySpreadConstraints: []
  deployment:
    annotations: {}
    strategy: {}
  revisionHistoryLimit: 10

  extraEnvs: []
  extraContainers: []
  extraVolumes: []
  extraInitContainers: []
  extraVolumeMounts: []
  extraLifecycle: {}

# LangWatch NLP configuration
langwatch_nlp:
  replicaCount: 1
  service: { type: ClusterIP, port: 5561 }
  resources:
    requests: { cpu: 1000m,  memory: 2Gi }
    limits:   { cpu: 2000m, memory: 4Gi }

  upstreams:
    langwatch: { name: langwatch-app,  port: 5560 }

  # == Pass through directly to k8s ==

  podSecurityContext: {}
  securityContext: {}
  nodeSelector: {}
  tolerations: []
  affinity: {}
  pod:
    annotations: {}
    labels: {}
    topologySpreadConstraints: []
  deployment:
    annotations: {}
    strategy: {}
  revisionHistoryLimit: 10

  extraEnvs: []
  extraContainers: []
  extraVolumes: []
  extraInitContainers: []
  extraVolumeMounts: []
  extraLifecycle: {}

# LangEvals configuration
langevals:
  replicaCount: 1
  service: { type: ClusterIP, port: 5562 }
  resources:
    requests: { cpu: 1000m,  memory: 6Gi }
    limits: { cpu: 2000m, memory: 8Gi }

  # == Pass through directly to k8s ==

  podSecurityContext: {}
  securityContext: {}
  nodeSelector: {}
  tolerations: []
  affinity: {}
  pod:
    annotations: {}
    labels: {}
    topologySpreadConstraints: []
  deployment:
    annotations: {}
    strategy: {}
  revisionHistoryLimit: 10

  extraEnvs: []
  extraContainers: []
  extraVolumes: []
  extraInitContainers: []
  extraVolumeMounts: []
  extraLifecycle: {}

# CronJobs configuration
cronjobs:
  enabled: true
  image:
    repository: curlimages/curl
    tag: latest
    pullPolicy: IfNotPresent
  resources:
    requests: { cpu: 100m,  memory: 64Mi }
    limits: { cpu: 100m, memory: 64Mi }

  upstreams:
    langwatch: { name: langwatch-app,  port: 5560 }

  # Individual cronjob configurations
  jobs:
    topicClustering:
      enabled: true
      schedule: "0 0 * * *" # At midnight every day
      endpoint: "/api/cron/schedule_topic_clustering"

    alertTriggers:
      enabled: true
      schedule: "*/3 * * * *" # Every 3 minutes
      endpoint: "/api/cron/triggers"

    tracesRetentionCleanup:
      enabled: true
      schedule: "0 1 * * *" # At 1 AM every day
      endpoint: "/api/cron/traces_retention_period_cleanup"

# Ingress configuration
ingress:
  enabled: false
  className: ""
  annotations: {}
  hosts:
    - host: chart-example.local
      http:
        paths:
          - path: /
            pathType: ImplementationSpecific
            backend:
              service:
                name: "langwatch-app"
                port:
                  number: 5560
  tls: []

# System Dependencies
prometheus:
  chartManaged: true # true for chart-managed, false for external

  external:
    # Reference to existing secret containing Prometheus connection details
    existingSecret: ""
    secretKeys:
      host: "host"
      port: "port"
      username: "username" # Optional for basic auth
      password: "password" # Optional for basic auth
      # Optional: full connection string
      connectionString: "connection-string"

  alertmanager:
    enabled: false

  pushgateway:
    enabled: false

  # Prometheus server configuration
  server:
    replicaCount: 1
    # Global Prometheus configuration
    global:
      scrape_interval: 15s
      evaluation_interval: 15s

    # Persistence configuration
    persistence:
      enabled: true
      size: 6Gi
      storageClass: ""

    # Retention and resources
    retention: 60d
    resources:
      requests:
        cpu: 200m
        memory: 512Mi
      limits:
        cpu: 500m
        memory: 2Gi

    # RBAC configuration (enabled by default)
    rbac:
      create: true
      includeDefaultRules: true

    # ServiceAccount configuration
    serviceAccount:
      create: true

    service:
      type: ClusterIP
      port: 9090

    securityContext:
      runAsNonRoot: true
      runAsUser: 65534
      fsGroup: 65534

# PostgreSQL configuration
postgresql:
  chartManaged: true # true for chart-managed, false for external

  # External PostgreSQL (when chartManaged: false)
  external:
    # Reference to existing secret containing connection details
    existingSecret: ""
    secretKeys:
      connectionString: "connection-string"

  auth:
    username: postgres
    password: "" # You must set this, it will not be auto-generated
    database: mydb
    existingSecret: ""
    secretKeys:
      usernameKey: "username"
      adminPasswordKey: "postgres-password"
      passwordKey: "password"
      databaseKey: "database"

  image:
    tag: 16.6.0-debian-12-r2

  postgresqlDataDir: /var/lib/postgresql/data/pgdata

  volumePermissions:
    enabled: true

  primary:
    persistence:
      enabled: true
      # if you are migrating from a `langwatch-helm` version before 1.0.0, you can set
      # this property and value your values.yaml file, and you will not lose any data
      # from the previous deployment

      # existingClaim: "data-langwatch-postgres-0"
      mountPath: /var/lib/postgresql/data
      size: 20Gi
      storageClass: ""

      readinessProbe:
        enabled: true
      livenessProbe:
        enabled: true

  resources:
    requests:
      cpu: 250m
      memory: 512Mi
    limits:
      cpu: 1000m
      memory: 1Gi

# OpenSearch configuration
opensearch:
  chartManaged: true # true for chart-managed, false for external

  external:
    engine: opensearch # opensearch, elasticsearch, quickwit
    nodeUrl:
      value: ""
      secretKeyRef: { name: "", key: "" }
    apiKey:
      value: ""
      secretKeyRef: { name: "", key: "" }

  auth:
    adminPassword: "" # Will be auto-generated if not provided
    existingSecret: "" # Use existing secret for production
    secretKeys:
      adminPasswordKey: "admin-password"

  fullnameOverride: langwatch-opensearch
  masterService: langwatch-opensearch
  clusterName: langwatch-opensearch
  replicas: 1

  config:
    opensearch.yml: |
      cluster.name: langwatch-opensearch
      node.name: langwatch-opensearch
      network.host: 0.0.0.0
      discovery.type: single-node
      plugins.security.disabled: true

  extraEnvs:
  - name: cluster.initial_master_nodes
    value: ""   # force empty so the setting is gone

  persistence:
    enabled: true
    size: 20Gi
    accessModes: [ReadWriteOnce]
    # storageClass: <set if you don’t have a default>

  resources:
    requests:
      cpu: 1000m
      memory: 2Gi
    limits:
      cpu: 2
      memory: 4Gi

# Redis configuration
redis:
  chartManaged: true # true for chart-managed, false for external

  external:
    architecture: standalone # standalone or cluster
    connectionString:
      value: ""
      secretKeyRef: { name: "", key: "" }

  auth:
    enabled: true
    password: "" # Will be auto-generated if not provided
    existingSecret: "" # Use existing secret for production
    secretKeys:
      passwordKey: "password"

  architecture: standalone
  master:
    persistence:
      enabled: true
      size: 10Gi
      storageClass: ""
    resources:
      requests:
        cpu: 250m
        memory: 256Mi
      limits:
        cpu: 500m
        memory: 512Mi
