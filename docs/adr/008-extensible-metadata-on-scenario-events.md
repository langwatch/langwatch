# ADR-008: Extensible Metadata on Scenario Events

**Date:** 2026-02-19

**Status:** Accepted

## Context

Scenario run events (`SCENARIO_RUN_STARTED`, `SCENARIO_RUN_FINISHED`, `SCENARIO_MESSAGE_SNAPSHOT`) follow the AG-UI event design and are emitted by the `@langwatch/scenario` SDK. The server receives them as-is and stores them in Elasticsearch -- there is no server-side enrichment.

The `RUN_STARTED` event has a `metadata` field, but it is strictly typed as `{ name, description }`. This creates two problems:

1. **Users cannot attach custom context to scenario runs.** There is no way to tie a prompt ID, environment, version, or any other custom context to a run. The only way to correlate a scenario run with what produced it is through traces, which is indirect and clunky.

2. **The LangWatch platform cannot attach orchestration context without polluting the core event schema.** The suite runner knows which target (agent/prompt) each run is executed against, but this information is lost after the BullMQ job completes -- it is never persisted. Adding platform-specific fields like `targetReferenceId` to the base event schema would leak internal concerns into the SDK's public contract.

## What we considered

**Option A: Top-level fields on `baseScenarioEventSchema`.**
Follows the pattern of `batchRunId` and `scenarioSetId`. However, target references are foreign keys into LangWatch's internal data (agents, prompts) -- they have no meaning for direct SDK users. Unlike `batchRunId` (which the SDK generates independently) and `scenarioSetId` (which is a generic grouping concept), target references are platform-specific. Adding them to the core schema sets a precedent for leaking platform concerns into the SDK contract.

**Option B: A `SUITE_RUN_STARTED` event capturing the full dispatch matrix.**
A single event per batch with `{ targets[], scenarioIds[], repeatCount }`. However, `scenarioRunId` is generated by the SDK at execution time -- the suite runner does not know it at dispatch time. So the event cannot map individual runs to targets without an additional join key, making the projection complex.

**Option C: Server-side enrichment at ingestion time.**
The API endpoint could look up the originating job and inject target info before writing to ES. This breaks the current "dumb pipe" architecture and adds operational complexity.

**Option D: Extensible metadata on events (chosen).**
Open the existing `metadata` field to accept arbitrary key-value pairs. Users put whatever they want. LangWatch puts platform context under a reserved `langwatch` namespace. The SDK passes it through. The server stores it.

## Decision

We will make the `metadata` field on scenario events extensible, with a reserved namespace for LangWatch platform data.

**SDK contract** (`@langwatch/scenario`, both JS and Python): `ScenarioConfig` accepts an optional `metadata` record. User-provided metadata is merged into the `RUN_STARTED` event's metadata alongside `name` and `description`.

```typescript
await scenario.run({
  name: "Login Test",
  agents: [myAgent],
  criteria: ["Agent greets user"],
  metadata: {
    environment: "staging",
    promptVersion: "v2.3",
  },
});
```

**Namespace convention**: The `langwatch` key within metadata is reserved for platform-internal use. Direct SDK users should not use it. LangWatch's suite runner populates it when dispatching jobs.

```json
{
  "type": "SCENARIO_RUN_STARTED",
  "metadata": {
    "name": "Login Test",
    "langwatch": {
      "targetReferenceId": "prompt_abc123",
      "targetType": "prompt",
      "simulationSuiteId": "suite_789"
    },
    "environment": "staging"
  }
}
```

**`langwatch` namespace fields** (strict Zod schema at the API layer):

| Field | Type | Required | Purpose |
|---|---|---|---|
| `targetReferenceId` | `string` | yes | ID of the agent/prompt target this run was executed against |
| `targetType` | `"prompt" \| "http" \| "code"` | yes | Target kind, matches `scenarioJobSchema.target.type` |
| `simulationSuiteId` | `string` | no | `SimulationSuite.id` â€” which suite dispatched this run |

The entire `langwatch` object is optional on metadata (SDK users never send it).

**Server-side schema**: The outer `metadata` uses `.passthrough()` so user-defined fields survive Zod parsing. The `langwatch` sub-object uses a strict schema (`langwatchMetadataSchema`) that validates field types and rejects unknown fields.

**ES mappings**: The `metadata` root uses `dynamic: false` so user-defined fields are stored in `_source` but not indexed (prevents mapping explosion from high-cardinality custom keys). The `metadata.langwatch` sub-object uses `dynamic: true` so platform fields are automatically indexed as keywords -- this means ES stays forward-compatible while the Zod layer enforces the contract at ingestion time.

**Projection**: `getScenarioRunDataBatch` reads `metadata` from `RUN_STARTED` events and exposes it on `ScenarioRunData`.

## Consequences

**Positive:**
- Users can attach arbitrary context to scenario runs
- LangWatch can store orchestration context without polluting the SDK's core schema
- Namespace convention prevents collisions
- No breaking changes -- omitting metadata preserves current behavior
- Future platform metadata needs use the same `langwatch` namespace without schema changes

**Negative:**
- User metadata is untyped beyond "JSON-serializable"
- ES `dynamic: true` on `metadata.langwatch` means any field sent there gets indexed; the Zod schema guards against this at the API layer, but bulk-inserted documents bypass it

**Neutral:**
- The server remains a dumb pipe
- The `@langwatch/scenario` SDK needs a release for both JS and Python packages

## References

- Related ADRs: [ADR-002: Event Sourcing](002-event-sourcing.md), [ADR-007: Event Sourcing Architecture](007-event-sourcing-architecture.md)
- GitHub issue: #1707
- SDK sub-issue: langwatch/scenario#228
